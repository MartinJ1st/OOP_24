/* Polimorfizam
 * Повикувањето на функции преку покажувач (или референца) секогаш резултираше во повикување на функциите од класата
 * на покажувачот , независно од типот на објектот кон кој моментално покажува покажувачот .

Ова однесување е познато како рано или статичко поврзување static binding бидејќи оваа информација е позната
 уште за време на преведувањето.

Полиморфизмот е механизам кој овозможува покажувач од базната класа автоматски (привидно) да го промени својот тип во
покажувач кон некоја од изведените класи, во зависност од типот на објектот кон кој моментално покажува.

Ова значи дека покажувачот vp ќе се однесува како Kamion кога ќе покажува кон објект од типот Kamion или
како Avtomobil кога покажува кон објект Avtomobil .

Полиморфизмот се реализира со можноста на C++ за т.н. „задоцнето" (late binding).
Кај задоцнетото поврзување одлуката која функција ќе се повика во одреден случај (од
базната класа или од некоја од изведените класи) повеќе не може да се донесе за време на
преведувањето на програмата, туку истата се одлага за во време на актуелното извршување
на програмата, кога единствено може да се донесе валидна одлука.

Задоцнетото поврзување во C++ се изведува со употреба на т.н. виртуелни функции членки на класата.

Виртуелните функции се декларираат со наведување на клучниот збор virtual пред декларацијата на функцијата во
класата. Еднаш декларирана како виртуелна, функцијата останува виртуелна во сите изведени класи
(дури и ако клучниот збор virtual не се повтори пред редефинирањето на функцијата во
изведените класи).

Како виртуелни се декларираат функциите во базната класа за кои се очекува да бидат препокриени
не е исто со редефинирани) од страна на изведените класи.( redefine != override)

Ефектите од задоцнетото поврзување се што при повикувањето на функција преку покажувач, ќе се повика
функцијата од класата од која е актуелниот објект (независно од типот на покажувачот) доколку истата
била декларирана како виртуелна во базната класа.

 Каде се користи полиморфизмот?

Полиморфизмот чини зголемени мемориски потреби. Со секој објект од класите кои имаат
виртуелни функции, покрај меморијата потребна за чување на податочните членови
потребно е да се чува уште еден покажувач кон табела на виртуелни функции за класата.
Со помош на оваа табела, за време на извршување на програмата може да се
одреди типот на објектот како и која функција треба да се повика за него.
 */

#include <iostream>
#include <string>

using namespace std;

class Base {
public:
    virtual int f() const {
        cout << "Base::f()\n";
        return 1;
    }

    virtual char f(string) const {}
    virtual void g() const {}
};

class Derived1 : public Base {
public:
    void g() const {}
};

class Derived2 : public Base {
public:
    //препокривање на виртуелна функција
    int f() const {
        cout << "Derived2::f()\n";
        return 2;
    }
};

class Derived3 : public Base {
public:
    //не може да се промени повратниот тип
    //! void f() const { cout << "Derived3::f()\n"; }
};

class Derived4 : public Base {
public:
    //промена на листата со аргументи
    int f(int) const {
        cout << "Derived4::f()\n";
        return 4;
    }
};

int main(){
    string s("hello");
    Derived1 d1;
    int x = d1.f();
    char c = d1.f(s);
    Derived2 d2;
    x = d2.f();
    //! c = d2.f(s); // string верзијата е скриена
    Derived4 d4;
    x = d4.f(1);
    //x = d4.f(); // f() верзијата е скриена
    //d4.f(s); // string верзијата е скриена
    Base &br = d4; // Upcast , референцата е од Base
    //br.f(1); // изведената верзија е недостапна
    br.f(); // верзијата од класата Base е достапна
    br.f(s); // верзијата од класата Base е достапна
}